### [Day1: 请写出下面代码执行的的结果](/note/daily/1)

<details>
<summary>分类：JavaScript

```js
console.log(1);
setTimeout(() => {
  console.log(2);
  process.nextTick(() => {
    console.log(3);
  });
  new Promise((resolve) => {
    console.log(4);
    resolve();
  }).then(() => {
    console.log(5);
  });
});
new Promise((resolve) => {
  console.log(7);
  resolve();
}).then(() => {
  console.log(8);
});
process.nextTick(() => {
  console.log(6);
});
setTimeout(() => {
  console.log(9);
  process.nextTick(() => {
    console.log(10);
  });
  new Promise((resolve) => {
    console.log(11);
    resolve();
  }).then(() => {
    console.log(12);
  });
});
```

</summary>

> 答案

```
node < 11
1 7 6 8 2 4 9 11 3 10 5 12

node >= 11
1 7 6 8 2 4 3 5 9 11 10 12
```

> 解析

!> 宏任务和微任务
1. 宏任务：
  1. `macrotask`,包括`setTimeout`、`setInerVal`、`setImmediate`(node独有)、`requestAnimationFrame`(浏览器独有)、`I/O`、`UI rendering`(浏览器独有)
1. 微任务：
  1. `microtask`,包括`process.nextTick`(Node独有)、`Promise.then()`、`Object.observe`、`MutationObserver`
  `Promise`构造函数中的代码是同步执行的，`new Promise()`构造函数中的代码是同步代码，并不是微任务

!> `Node.js`中的`EventLoop`执行宏队列的回调任务有6个阶段
1. `timers`阶段：这个阶段执行`setTimeout`和`setInterval`预定的`callback`
2. `I/O callback`阶段：执行除了`close`事件的`callbacks`、被`timers`设定的`callbacks`、`setImmediate()`设定的`allbacks`这些之外的`callbacks`
3. `idle, prepare`阶段：仅`node`内部使用
4. `poll`阶段：获取新的`I/O`事件，适当的条件下`node`将阻塞在这里
5. `check`阶段：执行`setImmediate()`设定的`callbacks`
6. `close callbacks`阶段：执行`socket.on('close', ....)`这些`callbacks`

!> `NodeJs`中宏队列主要有4个
1. `Timers Queue`
2. `IO Callbacks Queue`
3. `Check Queue`
4. `Close Callbacks Queue`

!> 这4个都属于宏队列，但是在浏览器中，可以认为只有一个宏队列，所有的macrotask都会被加到这一个宏队列中，但是在`NodeJS`中，不同的macrotask会被放置在不同的宏队列中。
`NodeJS`中微队列主要有2个
1. `Next Tick Queue`：是放置`process.nextTick(callback)`的回调任务的
2. `Other Micro Queue`：放置其他`microtask`，比如`Promise`等

在浏览器中，也可以认为只有一个微队列，所有的`microtask`都会被加到这一个微队列中，但是在`NodeJS`中，不同的`microtask`会被放置在不同的微队列中。

!> `Node.js`中的`EventLoop`过程
1. 执行全局`Script`的同步代码
2. 执行`microtask`微任务，先执行所有`Next Tick Queue`中的所有任务，再执行`Other Microtask Queue`中的所有任务
3. 开始执行`macrotask`宏任务，共6个阶段，从第1个阶段开始执行相应每一个阶段`macrotask`中的所有任务，注意，这里是所有每个阶段宏任务队列的所有任务，在浏览器的Event Loop中是只取宏队列的第一个任务出来执行，每一个阶段的macrotask任务执行完毕后，开始执行微任务，也就是步骤2
4. `Timers Queue` -> 步骤2 -> `I/O Queue` -> 步骤2 -> `Check Queue `-> 步骤2 -> `Close Callback Queue` -> 步骤2 -> `Timers Queue` ......
5. 这就是Node的Event Loop



```nomnoml renderSvg
# direction: right
[<reference> timers | pending callbacks | idle, prepare | poll | check | close callbacks ]
[incoming: connections, data, etc.] -> [poll]

```


Node 11.x新变化

现在`node11`在`timer`阶段的`setTimeout`,`setInterval`...和在`check`阶段的`immediate`都在`node11`里面都修改为一旦执行一个阶段里的一个任务就立刻执行微任务队列。为了和浏览器更加趋同.


</details>

